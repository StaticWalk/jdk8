package ect;

/**
 * Created by xiongxiaoyu
 * Data:2018/4/11
 * Time:21:52
 *
 * JMM(Java Memory Model)规定，程序中的变量是放在内存中，当线程需要使用该变量的时候，需要把该变量
 * 		复制到该CPU所在的工作内存(高速缓冲)中，直接获取高速缓存中的变量值，修改后还到高速缓存中，程
 * 		序执行完后，内存再冲高速缓存复制该变量的值。
 * JMM会出现，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。
 * 硬件层面的解决方法：
 * 	1).通过在总线加LOCK#锁的方式:CPU和其他部件通信通过总线进行的，在总线加LOCK锁能阻塞其他CPU对其他部件的访问
 * 		(内存)，使得只能有一个CPU使用这个变量的内存。  ???相当于多CPU单线程，效率低下
 * 2).通过缓存一致性协议：缓存一致性协议。Intel的MESI协议，保证了每个缓存中使用的共享变量是一直的，核心思想：
 * 		当CPU写数据时，如果操作变量是共享变量(其他CPU也存在该变量副本)，会发出信号通知其他CPU将该变量的缓存行
 * 		置无效状态，因此其他CPU读取这个变量时，发现自己缓存中改缓存行是无效的，便再次从内存中读取。
 *
 * 并发编程的三个概念
 *  1.原子性：一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
 *
 *
 *
 * Java提供的一种稍弱的同步机制，用来确保将变量的更新操作通知到其他线程，保证了新值能立即同
 * 		步到主内存，使用前能立即刷新。变脸声明volatile后，编译器和运行是都会注意到该变量共享
 * volatile变量对所有线程立即可见，所做操作能立即反应到其他线程中，基于volatile的操作是线程安全的 ？？？？
 *
 */
public class Volatile {
}
